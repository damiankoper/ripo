
\documentclass[12pt]{article}
\usepackage{scrextend}
\usepackage[utf8]{inputenc}
\usepackage[polish]{babel}
\usepackage[T1]{fontenc}%polskie znaki
\usepackage[utf8]{inputenc}%polskie znaki
\usepackage{geometry}
\usepackage{float}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{tabulary}
\usepackage{etoc}
\usepackage[normalem]{ulem} 
\usepackage{tikz}
\usepackage[bf]{caption}
\usepackage{amsmath}

\renewcommand{\baselinestretch}{1.5}

\usepackage{listings}
\usepackage{xcolor}
\usepackage[
    backend=bibtex,
    style=numeric
  ]{biblatex} 

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
 
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\renewcommand{\lstlistlistingname}{Spis listingów}\lstset{style=mystyle}

\graphicspath{ {img/} }
\newgeometry{lmargin=2.0cm, rmargin=2.0cm, tmargin=2.0cm, bmargin=2.0cm}
\clubpenalty=9996
\widowpenalty=9999
\brokenpenalty=4991
\predisplaypenalty=10000
\postdisplaypenalty=1549
\displaywidowpenalty=1602

\title{ 
    \vspace*{50mm}
    \textsc{
        \textbf{Rozpoznawanie i przetwarzanie obrazów}\\
        \large Śledzenie stanu stołu bilardowego 
    }
} 
\author{
Damian Koper,  241292\\
Mateusz Gurski, 242089
}

\date{\today}
\bibliography{literature}
\begin{document}

\maketitle

\newpage
\setcounter{tocdepth}{2}
\localtableofcontents
\listoffigures
\lstlistoflistings
\vfill
Repozytorium projektu: \url{https://github.com/damiankoper/ripo}
\newpage

\section{Cel projektu}
Celem projektu było stworzenie systemu umożliwiającego śledzenie stanu stołu podczas gry w bilard. Stan stołu obejmuje pozycję i numer bil obecnych na stole, jak i tych znajdujących się w łuzach. Obejmuje on również pozycje kija gracza.

\subsection{Cele dodatkowe}
Dodatkowym celem było rozpoznanie gracza aktualnie wykonującego ruch oraz zliczanie punktów i sygnalizowanie błędów i fauli.

\section{Stół bilardowy}

Kluczowym elementem projektu jest stół bilardowy. Na etapie projektowania systemu przyjęto następujące założenia dotyczące kamery i stołu:

\begin{enumerate}[noitemsep]
    \item Kamera jest umieszczona nad stołem, prostopadle do płaszczyzny stołu.
    \item Stół musi w całości zawierać się w kadrze zgodnie z orientacją kadru. Nie ma znaczenia jednak przesunięcie i obrót obrazu ($\pm45^\circ$).
    \item Stół musi być dobrze i jednolicie oświetlony.
    \item Przed rozpoczęciem działania systemu, po zmianie pozycji kamery, system musi wykonać proces inicjalizacji, który wymaga usunięcia wszystkich elementów ruchomych ze stołu.
\end{enumerate}

Ze względu na sytuację epidemiczną na terenie Polski w czasie prowadzenia prac nad projektem, nie było możliwości uzyskania dostępu do żadnego stołu, przeprowadzania i nagrania rozgrywki. Posiłkowano się nagraniami rozgrywek dostępnymi w serwisie YouTube z ustawieniami kamery spełniającymi wymagania\cite{youtube}.

\section{Przepływ danych i architektura}

Stworzony system składa się z dwóch głównych komponentów:
\begin{itemize}[noitemsep]
    \item VideoProcessor
    \item PoolVD
\end{itemize}

Komponent \textit{VideoProcessor} zajmuje się przetwarzaniem wideo i komunikacją z komponentem \textit{PoolVD}. Pozyskuje on obraz dostarczony poprzez strumieniem używającym protokołu UDP. Nie użyto tutaj protokołu TCP, ponieważ analiza stołu powinna odbywać się w czasie rzeczywistym i rozwiązanie to wprowadziłoby dodatkowy element synchronizacji, który mógłby mieć wpływ na dostarczany obraz.

Źródłem obrazu może być klip wideo wysyłany z użyciem narzędzie \textit{ffmpeg}, albo obraz na żywo z kamery RaspberryPI. Oba te rozwiązania zostały przetestowane. Wykorzystanie strumienia sieciowego jako źródła obrazu jest rozwiązaniem uniwersalnym, ponieważ oferuje stabilny interface po stronie komponentu \textit{VideoProcessor}.

Komponent \textit{VideoProcessor} jest równocześnie serwerem obsługującym połączenia zgodne z protokołem WebSocket. Umożliwia to na szybkie dostarczanie danych wyjściowych do dowolnej liczby klientów. Umożliwia to również na opartą na zdarzeniach komunikację pomiędzy klientami wyświetlającymi dane, omówioną w dalszej części sprawozdania. Protokół WebSocket, w przeciwieństwie do HTTP do dwukierunkowej komunikacji wykorzystuje zawsze jeden strumień.

Przepływ danych od materiału wideo do użytkownika zobrazowane zostało na diagramie z rysunku \ref{dataflow}.


\begin{figure}[!ht]
    \centering
    \includegraphics[width=10cm]{./diagrams/out/data_flow.png}
    \caption{Przepływ danych.}
    \label{dataflow}
\end{figure}

\subsection{Architektura}

Detekcja, klasyfikacja, wyświetlania i dedukcja są złożonymi procesami używającymi wiele zasobów sprzętowych. Jednym z filarów sprawnego działania systemu jest sprawny przepływ danych i wielokrotne używanie produktów pośrednich tego przetwarzania. Aby uzyskać płynność przetwarzanego obrazu i optymalne wykorzystanie zasobów wykorzystano podejście wielowątkowe połączone z asynchronicznością.

\subsection{Komponent VideoProcessor}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=14cm]{./diagrams/out/video_processor_cd.png}
    \caption{Diagram klas komponentu VideoProcessor.}
    \label{vp_cd}
\end{figure}

Punktem wejścia programu jest moduł \lstinline{main}. Przyjmuje on argumenty określające jego działanie - parametry strumienia wejściowego oraz tryb pracy. Może on zostać uruchomiony w trybie domyślnej analizy obrazu lub w celu jego nagrania. Dalszy opis tyczy się trybu analizy obrazu.

Działanie przetwarzania klatki bazuje na działaniu trzech głównych klas - procesów systemowych, nazwanych procesorami. Każdy z nich posiada swój rozbudowany obiekt konfiguracji. Ogólną strukturę klas komponentu przedstawia diagram na rysunku~\ref{vp_cd}.

\begin{enumerate}
    \item \textbf{VideoProcessor}. Nazwa taka sama jak nazwa całego komponentu. Klasa odpowiedzialna za odebranie klatki i oddanie sterowania do klasy \lstinline{InitialFrameProcessing} w celu wykonania procesu inicjalizacji i wstępnego przetworzenia klatki. Po wstępnym przetworzeniu umieszcza ona produkty tego przetwarzania klatki w zmiennych współdzielonych pomiędzy innymi klasami - procesorami.
    \item \textbf{BallProcessor}. Klasa odpowiedzialna za detekcję i klasyfikację bil. W celu klasyfikacji wykrytych bil klasa ta przekazuje sterowanie do klasy \lstinline{Classification}.
    \item \textbf{CueProcessor}. Klasa odpowiedzialna za detekcję kija. %TODO MAti jak się się zmieniło to dopisz tu ogólnie
\end{enumerate}

Procesy \textbf{BallProcessor} i \textbf{CueProcessor} przed rozpoczęciem przetwarzania oczekują na klatkę, jeśli nie jest ona dostępna. Dzięki funkcjonowaniu zmiennych współdzielonych, w których przekazywane są klatki przez \textbf{VideoProcessor}, oba procesory w momencie rozpoczęcia przetwarzania pobierają zawsze aktualne dane. Pozwala to na przetwarzanie niezależnie od wydajności algorytmów w poszczególnych klasach.

Po zakończeniu przetwarzania każdej klatki \textbf{BallProcessor} i \textbf{CueProcessor} wysyłają wynik swoich działań w postaci obiektów \lstinline{Ball} lub \lstinline{Cue} do kolejek modułu OutputModule.

\subsubsection{OutputModule}

OutputModule jest osobnym procesem, który obsługuje trzy procedury:
\begin{enumerate} [noitemsep]
    \item Serwer komunikacji zewnętrznej - \lstinline{WebSocketServer}.
    \item Obserwator kolejki wykrytych bili.
    \item Obserwator kolejki wykrytych kii.
\end{enumerate}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=9cm]{./diagrams/out/pull_state_cd.png}
    \caption{Struktura PoolState.}
    \label{poolstate}
\end{figure}

Moduł zawiera również ostatni aktualny wykryty stan stołu. Strukturę te prezentuje diagram na rysunku \ref{poolstate}.
Obserwatory obserwujące kolejkę, po umieszczeniu w nich danych przez moduły \textbf{BallProcessor} i \textbf{CueProcessor} aktualizują obiekt \lstinline{PoolState} i wymuszają wysłanie stanu stołu do klientów przez serwer.

Protokół WebSocket umożliwia komunikację full-duplex w dowolny sposób. W celu ustandaryzowania komunikacji pomiędzy klientami, a serwerem zdecydowano się wybrać zorientowaną zdarzeniowo bibliotekę Socket.IO \cite{socket.io}.

Proces przesyłania stanu stołu do komponentu \textbf{PoolVD} obrazuje diagram na rysunku \ref{pool_state_sd}. Obsługę zdarzenia zmiany opcji czasu trwania okresu inicjalizacji z poziomu interfejsu użytkownika prezentuje diagram na rysunku \ref{pool_vd_events_sd}.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=15cm]{./diagrams/out/pool_state_sd.png}
    \caption{Proces przesyłania stanu stołu do komponentu \textbf{PoolVD}.}
    \label{pool_state_sd}
\end{figure}


Każda z klas obsługujących zdarzenia ma dostęp do swojej kolejki, w której \textbf{OutputModule} umieszcza przychodzące obiekty zdarzeń. Klasa obsługuje tylko takie zdarzenia, których obsługa została przewidziana i ignoruje nieznane. Rozwiązanie to pozwala na łatwe rozszerzenie konfiguracji i zachowania każdej z klas bez żadnego wpływu na inne klasy - wystarczy tylko zaimplementować odbiór i obsługę nowego zdarzenia.


\begin{figure}[!ht]
    \centering
    \includegraphics[width=15cm]{./diagrams/out/pool_vd_events_sd.png}
    \caption{Obsługa zdarzenia wywołanego przez \textbf{PoolVD}.}
    \label{pool_vd_events_sd}
\end{figure}

\subsection{Komponent PoolVD}
Komponent PoolVD odpowiada za wyświetlanie otrzymanego stanu stołu, odrzucanie stanów nieprawdopodobnych i śledzenie wpadnięć bili do łuz. Wysyła on również zdarzenia do komponentu \textbf{VideoProcessor}, które aktualizują parametry detekcji i wywołują zdefiniowane akcje.

Komponent tworzy historię stanów stołu. Na tej podstawie wykonuje następujące procedury dla każdej bili:

\begin{enumerate} [noitemsep]
    \item Wyświetlanie ostatniego otrzymanego stanu. Eliminuje to tymczasowe zniknięcia bili spowodowane błędem detekcji, klasyfikacji, albo zasłonięciem bili przez inny obiekt.
    \item Odrzucenie stanów nieprawdopodobnych. Na podstawie stanów poprzednich, przychodzący stan bili może być odrzucony, jeśli bila przemieściła się nienaturalnie szybko w inną część stołu. Odrzuca to pojedyncze błędy klasyfikacji. Heurystyką używaną w tym wnioskowaniu jest prędkość średnia bili uzyskana na podstawie poprzednich stanów.
    \item Wykrycie wpadnięcia bili do łuzy. Bila jest uznana za wpadniętą do łuzy jeśli przez konfigurowalną liczbę stanów była niewykryta, a jej ostatnia znana była pozycją blisko danej łuzy.
\end{enumerate}

Każda z procedur ma konfigurowalną precyzję podaną jako liczbę stanów.

\section{Detekcja i klasyfikacja}
% TODO Wszystko zaczyna się w Videoprocessor tu się pozyskuje obraz i robi wstępny proces jego przetwarzania - wycinanie itd, to jak wycinać i co wysłać dalej jest ustalane w procesie inicjalizacji

%Ważne opisać współrzędne znormalizowane (0,0) do (2,1)

\subsection{Proces inicjalizacji}
% Uśrednianie klatki
% detekcja stoł↓
% Polepszanie macierzy transformacji
% Ważne - zaznaczyć, że inicjalizacja działa nawet po jednej klatce, tylko im więcej tym lepiej
% możę skrinki z zaznaconym wykrytym stołem

\subsection{Produkty przetwarzania wstępnego}
% tutaj skrinki możę ze 2 tej średniej klatki i obecnej wyciętej
% pamiętaj o \ref w tekście i [!ht] to latex to ładnie ułoży

\subsection{Bile}
%cały proces opisać BP
% Ważne opisz konfigurowalne parametry z poziomu frontu
\subsection{Kij}

%cały proces opisać CP
% Ważne opisz konfigurowalne parametry z poziomu frontu

\section{Interface użytkownika}

Wyświetlanie stołu odbywa się w komponencie \textbf{PoolVD}. Aplikacja webowa stworzona z wykorzystaniem frameworka Vue i Vuetify, na komponencie Canvas rysuje stół wraz z aktualną, wydedukowaną zawartością łuz (rysunek \ref{pool1}). Białe półprzezroczyste elipsy wokół łuz obrazują obszar działania dedukcji wpadnięcia bili do łuzy. Pełny widok interfejsu graficznego przedstawia rysunek \ref{interface}.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=15cm]{./images/pool1.png}
    \caption{Widok stołu w komponencie \textbf{PoolVD}.}
    \label{pool1}
\end{figure}

Aplikacja posiada wysuwalny panel (rysunek \ref{options}), z którego poziomu można zmieniać parametry detekcji i dedukcji. Zmiany ustawień detekcji generują opisane wcześniej zdarzenia, które odbierane są przez komponent \textbf{VideoProcessor}. Zmiany ustawień dedukcji mają efekt tylko na poziomie komponentu \textbf{PoolVD}.

\begin{figure}[!ht]
    \centering
    \includegraphics[height=20cm]{./images/options.png}
    \caption{Panel opcji w komponencie \textbf{PoolVD}.}
    \label{options}
\end{figure}

Z racji na możliwość powstania przesunięcia i zaburzeń proporcji stołu w kamerze ustawienia pozwalają na zmianę przesunięcia i skali wyświetlanych elementów stołu. Jest to końcowym etapem bezpośrednio poprzedzającym wyświetlanie elementów stołu, więc dedukcja i analiza pozycji odbywa się na danych otrzymanych od komponentu \textbf{VideoProcessor}.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=\linewidth]{./images/interface.png}
    \caption{Interfejs komponentu \textbf{PoolVD} z testowymi danymi.}
    \label{interface}
\end{figure}

\section{Uruchomienia systemu}
% TODO Damian
\section{Podsumowanie i wnioski}
% TODO Damian i MAti
\clearpage
\newpage

\printbibliography

\end{document}